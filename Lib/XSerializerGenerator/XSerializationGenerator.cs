using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp.Symbols.PublicModel;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace XSerializerGenerator;

[Generator]
public class XSerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classTypes = context.SyntaxProvider.CreateSyntaxProvider(FilterClasses, SelectClasses).Where(type => type is not null && type.Name != "XSerializer" && type.Name != "XSerializerGen").Collect();
        context.RegisterSourceOutput(classTypes, GenerateCode);
    }

    private static bool FilterClasses(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        if (syntaxNode is ClassDeclarationSyntax classNode)
        {
            if (classNode.Identifier.ValueText == "XSerializer" || classNode.Identifier.ValueText == "XSerializerGen")
            {
                return false;
            }
            if (classNode.Modifiers.Any(m => m.ValueText == "static"))
            {
                return false;
            }

            var modifiers = classNode.Modifiers.ToArray();
            var members = classNode.Members.ToArray();  
            var properties = classNode.Members.Where(m => m is PropertyDeclarationSyntax).ToArray();
            return true;
        }
        //if (classNode.Identifier.ValueText == "XSerializer" || classNode.Identifier.ValueText != "XSerializerGen")
        //{

        //}
        return false;
    }

    private static ITypeSymbol SelectClasses(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var classNode = context.Node as ClassDeclarationSyntax;
        SyntaxToken token = classNode.Identifier;
        string name = token.ValueText;
        var sym = context.SemanticModel.GetDeclaredSymbol(classNode);
        return sym as ITypeSymbol;
    }

    private static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol> enumerations)
    {
        if (enumerations.IsDefaultOrEmpty)
        {
            return;
        }
        var l = enumerations.Distinct().ToArray();

        StringBuilder code = new StringBuilder();
        code.AppendLine(@$"// <auto-generated />
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.Json;
using System.Xml;
using AVMHomeAutomation;
using AVMHomeAutomation.Converter;

namespace Serialization
{{
    internal static class XSerializerGen
    {{
        public static string Serialize(object value, Type inputType, XmlWriterSettings settings = null)
        {{
            StringBuilder sb = new StringBuilder();
            XmlWriter writer = XmlWriter.Create(sb, settings);
            Serialize(writer, value, inputType);
            writer.Flush();
            writer.Close();
            return sb.ToString();
        }}
                
        public static void Serialize(XmlWriter writer, object value, Type inputType)
        {{
            switch (inputType.FullName)
            {{
            case nameof(DeviceList): SerializeDeviceList(writer, (DeviceList)value, inputType); break;
            case nameof(Device): SerializeDeviceList(writer, (DeviceList)value, inputType); break;
            case nameof(Group): SerializeDeviceList(writer, (DeviceList)value, inputType); break;
            default: throw new ArgumentException(""Unknown type"", inputType.Name);
            }}
        }}

        public static object Deserialize(string xml, Type returnType, XmlReaderSettings settings = null)
        {{
            XmlReader reader = XmlReader.Create(new StringReader(xml), settings);
            return Deserialize(reader, returnType);
        }}

        public static object Deserialize(XmlReader reader, Type returnType)
        {{
            object result = null;
            reader.MoveToContent();
            switch (returnType.FullName)
            {{
            case ""AVMHomeAutomation.DeviceList"": result = DeserializeDeviceList(reader, returnType); break;
            case nameof(Device): result = DeserializeDeviceList(reader, returnType); break;
            case nameof(Group): result = DeserializeDeviceList(reader, returnType); break;
            default: throw new ArgumentException(""Unknown type"", returnType.Name);
            }};
            return result;
        }}

");

        foreach (ISymbol type in enumerations.Distinct())
        {
            //NonErrorNamedTypeSymbol noErrorNamedTypeSymbol = type as NonErrorNamedTypeSymbol;
            //var code = GenerateCode(type);
            //var typeNamespace = type.ContainingNamespace.IsGlobalNamespace
            //       ? null
            //       : $"{type.ContainingNamespace}.";

            //context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
            code.AppendLine(@$"
        private static void Serialize{type.Name}(XmlWriter writer, {type.Name} value, Type inputType)
        {{
            writer.WriteStartElement(""{type.Name}"");
            //writer.WriteAttributeString(""version"", value.Version);
            //writer.WriteAttributeString(""fwversion"", value.FirmwareVersion);
            //foreach (var item in value.DevicesList)
            //{{
            //    SerializeDevice(item, writer);
            //}}
            //foreach (var item in value.GroupsList)
            //{{
            //    SerializeGroup(item, writer);
            //}}
            writer.WriteEndElement();
        }}

        private static {type.Name} Deserialize{type.Name}(XmlReader reader, Type inputType)
        {{
            return new {type.Name}();
        }}
");
        }

        code.AppendLine(@$"
    }}
}}");
        
        //context.AddSource("XSerializer.g.cs", code.ToString());
    }

    private static string GenerateCode(ITypeSymbol type)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace
              ? null
              : type.ContainingNamespace.ToString();
        var name = type.Name;
        var items = GetItemNames(type);

        return @$"// <auto-generated />

using System.Collections.Generic;

{(ns is null ? null : $@"namespace {ns}
{{")}
   partial class {name}Xxx
   {{
      //private static IReadOnlyList<{name}> _items;
      //public static IReadOnlyList<{name}> Items => _items ??= GetItems();

      //private static IReadOnlyList<{name}> GetItems()
      //{{
      //   return new[] {{ {String.Join(", ", items)} }};
      //}}
   }}
{(ns is null ? null : @"}
")}";
    }

    private static IEnumerable<string> GetItemNames(ITypeSymbol type)
    {
        return type.GetMembers()
                   .Select(m =>
                   {
                       if (!m.IsStatic ||
                      m.DeclaredAccessibility != Accessibility.Public ||
                      m is not IFieldSymbol field)
                           return null;

                       return SymbolEqualityComparer.Default.Equals(field.Type, type)
                            ? field.Name
                            : null;
                   })
                   .Where(field => field is not null);
    }
}